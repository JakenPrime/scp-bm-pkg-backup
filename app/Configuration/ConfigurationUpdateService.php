<?php

namespace Packages\Backup\App\Configuration;

use App\Support\Http\UpdateService;
use Illuminate\Support\Collection;

class ConfigurationUpdateService extends UpdateService {
  /**
   * @var ConfigurationFormRequest
   */
  protected $request;

  /**
   * @var string
   */
  protected $requestClass = ConfigurationFormRequest::class;

  public function afterCreate(Collection $items) {
    $createEvent = $this->queueHandler(
      Events\ConfigurationBackupCreated::class
    );

    $this->successItems(
      'pkg.backup::configuration.created',
      $items->each($createEvent)
    );
  }

  /**
   * @param Collection $items
   *
   * @throws \App\Api\Exceptions\ApiKeyExpired
   * @throws \App\Api\Exceptions\ApiKeyNotFound
   */
  protected function beforeAll(Collection $items) {
    $this->enforceAdmin();

    $items->each(function (Configuration $item) {
      $item->assertHasPermissionToEdit();
    });
  }

  /**
   * @throws \App\Api\Exceptions\ApiKeyExpired
   * @throws \App\Api\Exceptions\ApiKeyNotFound
   */
  protected function enforceAdmin() {
    // TODO enforce this in Configuration edit permissions, but that requires a new permission check type.
    if (!$this->auth->is('admin')) {
      abort(
        403,
        'Only administrators are allowed access to this functionality.'
      );
    }
  }

  /**
   * @param Collection $items
   *
   * @throws \App\Api\Exceptions\ApiKeyExpired
   * @throws \App\Api\Exceptions\ApiKeyNotFound
   */
  protected function beforeCreate(Collection $items) {
    $this->enforceAdmin();
    $items->each(
      $this->changed([
        'admin_id' => $this->auth->id(),
      ])
    );
  }

  protected function beforeUpdate(Collection $items) {
    parent::beforeUpdate($items); // TODO: Change the autogenerated stub
  }

  /**
   * Update all archives using the given request.
   *
   * @param Collection $items
   */
  public function updateAll(Collection $items) {
  }
}
